# PLIB Emscripten Build Guide

This guide documents how to build PLIB 1.8.5 for WebAssembly using Emscripten on Windows (Git Bash).

## Usage

```bash
cd external/plib

source ../../emscripten-env.sh

./configure --prefix=$(pwd)/../../export --build=x86_64-w64-mingw32 --host=i686-pc-mingw32 --disable-dependency-tracking INSTALL="$(pwd)/install-sh"

make
make install
```

---

## Build Details

The sections below document the changes needed to compile PLIB with Emscripten. This may be useful if you are porting something to WebAssembly or need to debug build issues.

### Configure Options

`--prefix=$(pwd)/../../export` sets the installation location to `export/` at the project root. Using `$(pwd)/../../` ensures an absolute path is generated during configuration, avoiding issues with relative paths during `make install`.

`--build=x86_64-w64-mingw32` explicitly mentions the build type to avoid `cannot guess build type` errors. As `config.guess` script has not been updated in a while, it cannot recognize current MINGW64 environments.

`--host=i686-pc-mingw32` triggers the Windows code path in PLIB's `configure.in`:

```m4
case "${host}" in
*-*-cygwin* | *-*-mingw32*)
    dnl CygWin under Windoze.

    dnl Multimedia library
    LIBS="$LIBS -lwinmm"

    if test "x$need_opengl" = "xyes"; then
        dnl OpenGL libraries
        LIBS="$LIBS -lopengl32"
    fi
	;;
...
*)
    if test "x$need_opengl" = "xyes"; then
        dnl Check for X11

        AC_PATH_XTRA

        LDFLAGS="$LDFLAGS $X_LIBS"

        LIBS="$LIBS $X_PRE_LIBS -lXi -lXmu -lXext -lX11 $X_EXTRA_LIBS -lm"

        AC_CHECK_LIB(GL, glNewList)
        ...
    fi
    ;;
esac
```

The `*` fallback adds X11 libraries (`-lXi -lXmu -lXext -lX11`) and checks for `-lGL`. By pretending to be mingw32, the Windows branch takes effect which skips X11 and adds `-lopengl32`.

`--disable-dependency-tracking`: On Git Bash, `$(SHELL)` resolves to `C:/Program Files/Git/usr/bin/sh.exe`. The space in `Program Files` breaks unquoted paths due to `depcomp = $(SHELL) $(top_srcdir)/depcomp` and fails with:

```
/usr/bin/sh: line 1: C:/Program: No such file or directory
```

Replacing all instances of `depcomp = $(SHELL) $(top_srcdir)/depcomp` with `depcomp = "$(SHELL)" "$(top_srcdir)/depcomp"` would fix this issue, but as `Makefile.in` is generated by automake, the edit would be lost on regeneration. Instead, disabling dependency tracking bypasses this issue. Dependency tracking only matters for incremental builds; for a one-time compilation, it is not necessary.

`INSTALL="$(pwd)/install-sh"` uses the bundled autoconf `install-sh` script instead of the system's `/usr/bin/install`. For Git Bash on Windows, the system install resolves to `/c/Program Files/Git/usr/bin/install.exe`, which breaks Makefile commands due to the space in the path. The bundled script does not have this issue.

---

### Platform Detection

`src/util/ul.h` uses `#ifdef` checks to detect the OS. Emscripten's compiler defines `__unix__`, which matches the `UL_BSD` fallback:

```c
#elif (defined(__unix__) || defined(unix)) && !defined(USG)
#define UL_BSD       1
#endif
```

When `UL_BSD` is defined, `src/js/jsBSD.cxx` tries to include BSD-specific joystick headers:

```c
#if defined (UL_BSD)
...
#if defined(__FreeBSD__)
# include <sys/joystick.h>
#else
# include <machine/joystick.h>    // For analog joysticks
#endif
```

This causes the build to fail:

```
jsBSD.cxx:53:11: fatal error: 'machine/joystick.h' file not found
   53 | # include <machine/joystick.h>          // For analog joysticks
```

To fix this issue, add Emscripten detection before the BSD fallback in `src/util/ul.h`:

```c
#elif defined(__EMSCRIPTEN__)
#define UL_EMSCRIPTEN 1
#elif (defined(__unix__) || defined(unix)) && !defined(USG)
#define UL_BSD       1
#endif
```

### POSIX Headers

`src/util/ul.h` has an includes block that provides POSIX headers for Unix-like platforms:

```c
#if defined(UL_LINUX) || defined(UL_BSD) || defined(UL_IRIX) || defined(UL_SOLARIS) || defined(UL_AIX)
#include <unistd.h>
#include <dlfcn.h>
#include <fcntl.h>
#define  UL_GLX     1
#endif
```

Emscripten supports `unistd.h`, `dlfcn.h`, and `fcntl.h`, but as it is not present in the `if` condition, the build fails with:

```
.\ul.h:254:5: error: use of undeclared identifier 'sleep'
.\ul.h:267:5: error: use of undeclared identifier 'usleep'
.\ul.h:716:41: error: use of undeclared identifier 'RTLD_NOW'
.\ul.h:724:36: error: use of undeclared identifier 'dlsym'
.\ul.h:730:7: error: use of undeclared identifier 'dlclose'
```

To fix this issue, add `UL_EMSCRIPTEN` to the `if` condition:

```c
#if defined(UL_LINUX) || defined(UL_BSD) || defined(UL_IRIX) || defined(UL_SOLARIS) || defined(UL_AIX) || defined(UL_EMSCRIPTEN)
#include <unistd.h>
#include <dlfcn.h>
#include <fcntl.h>
#define  UL_GLX     1
#endif
```

### Joystick Stub

The joystick library has platform-specific backends (`jsLinux.cxx`, `jsWindows.cxx`, etc.). For platforms without native joystick support, `src/js/jsNone.cxx` provides a stub implementation:

```c
#if defined(UL_IRIX) || defined(UL_SOLARIS) || defined(UL_HPUX)

struct os_specific_s ;

void jsJoystick::open ()
{
  error = TRUE ;
  num_axes = num_buttons = 0 ;
  ...
}
```

While Gamepad API exists, PLIB's joystick code expects OS-level device files (`/dev/input/js0`) which do not exist in WebAssembly.

So, add `UL_EMSCRIPTEN` to the guard in `src/js/jsNone.cxx`:

```c
#if defined(UL_IRIX) || defined(UL_SOLARIS) || defined(UL_HPUX) || defined(UL_EMSCRIPTEN)
```

### Sound Library

`src/sl/sl.h` defines a default audio device path for each platform:

```c
#ifdef SL_USING_OSS_AUDIO
#define SLDSP_DEFAULT_DEVICE "/dev/dsp"
#elif defined(UL_WIN32)
#define SLDSP_DEFAULT_DEVICE "dsp"
#elif defined(UL_BSD)
#define SLDSP_DEFAULT_DEVICE "/dev/audio"
...
#elif defined(UL_MACINTOSH) || defined(UL_MAC_OSX)
#define SLDSP_DEFAULT_DEVICE "dsp" // dummy
#else
#error "Port me !"
#endif
```

It also has an `ioctl` method for Unix systems that controls the audio device:

```c
#if !defined(UL_WIN32) && !defined(UL_MACINTOSH) && !defined(UL_MAC_OSX)
  int ioctl ( int cmd, int param = 0 )
  {
    if ( error ) return param ;

    if ( ::ioctl ( fd, cmd, & param ) == -1 )
    {
      perror ( "slDSP: ioctl" ) ;
      error = SL_TRUE ;
    }

    return param ;
  }
```

Since `UL_EMSCRIPTEN` is not present in either `#if` chain, the build fails. The first chain falls through to `#error "Port me !"`, and the second chain includes the `ioctl` method which calls `::ioctl()`, a system call that does not exist in Emscripten:

```
.\sl.h:48:2: error: "Port me !"
.\sl.h:128:10: error: no member named 'ioctl' in the global namespace
.\sl.h:169:12: error: use of undeclared identifier 'SLDSP_DEFAULT_DEVICE'
```

To fix this issue, add Emscripten before the `#error` fallback in `src/sl/sl.h`:

```c
#elif defined(UL_MACINTOSH) || defined(UL_MAC_OSX)
#define SLDSP_DEFAULT_DEVICE "dsp" // dummy
#elif defined(UL_EMSCRIPTEN)
#define SLDSP_DEFAULT_DEVICE "dsp" // dummy - Emscripten uses OpenAL/Web Audio
#else
#error "Port me !"
#endif
```

To fix the `ioctl` error, exclude Emscripten from the method. TORCS uses OpenAL (which Emscripten maps to Web Audio), not direct DSP access:

```c
#if !defined(UL_WIN32) && !defined(UL_MACINTOSH) && !defined(UL_MAC_OSX) && !defined(UL_EMSCRIPTEN)
  int ioctl ( int cmd, int param = 0 )
```

### GLX Includes (`src/ssg/ssg.cxx`)

`src/ssg/ssg.cxx` includes platform-specific OpenGL context headers:

```c
#if defined(UL_MACINTOSH)
#  include <agl.h>
#elif defined(UL_MAC_OSX)
#  include <OpenGL/CGLCurrent.h>
#elif defined(UL_WIN32)
   /* Nothing */
#else
#  include <GL/glx.h>
#endif
```

It also has a `glIsValidContext()` function that checks if an OpenGL context is active:

```c
static bool glIsValidContext ( void )
{
#if defined(CONSOLE)
  return true ;
#elif defined(UL_WIN32)
  return ( wglGetCurrentContext () != NULL ) ;
#elif defined(UL_MACINTOSH)
  return ( aglGetCurrentContext () != NULL ) ;
#elif defined(UL_MAC_OSX)
  return ( CGLGetCurrentContext () != NULL ) ;
#else
  return ( glXGetCurrentContext () != NULL ) ;
#endif
}
```

Emscripten uses WebGL and does not have GLX. As a result, the build fails with:

```
ssg.cxx:35:12: fatal error: 'GL/glx.h' file not found
   35 | #  include <GL/glx.h>
      |            ^~~~~~~~~~
```

```
ssg.cxx:49:12: error: use of undeclared identifier 'glXGetCurrentContext'
   49 |   return ( glXGetCurrentContext () != NULL ) ;
      |            ^~~~~~~~~~~~~~~~~~~~
```

To fix this issue, add Emscripten to the Windows branch in `src/ssg/ssg.cxx`:

```c
#if defined(UL_MACINTOSH)
#  include <agl.h>
#elif defined(UL_MAC_OSX)
#  include <OpenGL/CGLCurrent.h>
#elif defined(UL_WIN32) || defined(UL_EMSCRIPTEN)
   /* Nothing */
#else
#  include <GL/glx.h>
#endif
```

Also add an Emscripten case to `glIsValidContext()` that returns `true` because, in the browser, the code running implies WebGL context exists:

```c
static bool glIsValidContext ( void )
{
#if defined(CONSOLE)
  return true ;
#elif defined(UL_WIN32)
  return ( wglGetCurrentContext () != NULL ) ;
#elif defined(UL_MACINTOSH)
  return ( aglGetCurrentContext () != NULL ) ;
#elif defined(UL_MAC_OSX)
  return ( CGLGetCurrentContext () != NULL ) ;
#elif defined(UL_EMSCRIPTEN)
  return true ;
#else
  return ( glXGetCurrentContext () != NULL ) ;
#endif
}
```

### Version String

In `src/ssg/ssg.cxx`, the `ssgGetVersion()` function returns the `VERSION` macro:

```c
const char *ssgGetVersion ()
{
  return VERSION ;
}
```

`VERSION` is defined by autoconf as `1.8.5` (without quotes). The compiler interprets this as a floating-point literal with an invalid suffix, causing the build to fail:

```
ssg.cxx:81:10: error: invalid suffix '.5' on floating constant
   81 |   return VERSION ;
      |          ^
<command line>:8:20: note: expanded from macro 'VERSION'
    8 | #define VERSION 1.8.5
      |                    ^
```

To fix this issue, we can use stringify macros to convert the macro value to a string literal in `src/ssg/ssg.cxx`:

```c
#define _SSG_STRINGIFY(x) #x
#define SSG_STRINGIFY(x) _SSG_STRINGIFY(x)

const char *ssgGetVersion ()
{
  return SSG_STRINGIFY(VERSION) ;
}
```

### Type Definitions (`src/ssg/ssgLoadFLT.cxx`)

The FLT loader uses `ushort` and `uint` types. These are non-standard type aliases available on some Unix systems via `<sys/types.h>`.

```c
#ifdef UL_WIN32
typedef unsigned short ushort;
typedef unsigned int uint;
#endif
```

As Emscripten does not provide these type aliases, the build fails with:

```
ssgLoadFLT.cxx:173:4: error: use of undeclared identifier 'ushort'
ssgLoadFLT.cxx:185:4: error: unknown type name 'uint'
```

However, as `src/ssg/ssgLoadFLT.cxx` already has typedefs for `WIN32` to handle this issue, we can just add `UL_EMSCRIPTEN` to the `if` condition:

```c
#if defined(UL_WIN32) || defined(UL_EMSCRIPTEN)
typedef unsigned short ushort;
typedef unsigned int uint;
#endif
```

### GLX in PUI (`src/pui/pu.cxx`)

The PUI (Portable UI) library checks `UL_GLX` to decide whether to include GLX headers:

```c
#ifdef UL_GLX
#  include <GL/glx.h>
#endif
```

Earlier in the POSIX Headers section, we added `UL_EMSCRIPTEN` to the include block and kept `UL_GLX` defined for all platforms. This causes the build to fail for Emscripten:

```
pu.cxx:31:12: fatal error: 'GL/glx.h' file not found
   31 | #  include <GL/glx.h>
      |            ^~~~~~~~~~
```

To fix this issue, return to `src/util/ul.h` and exclude Emscripten from defining `UL_GLX`:

```c
#if defined(UL_LINUX) || defined(UL_BSD) || defined(UL_IRIX) || defined(UL_SOLARIS) || defined(UL_AIX) || defined(UL_EMSCRIPTEN)
#include <unistd.h>
#include <dlfcn.h>
#include <fcntl.h>
#if !defined(UL_EMSCRIPTEN)
#define  UL_GLX     1
#endif
#endif
```

### GLX Includes (`src/fnt/fntTXF.cxx`)

Similar to `src/ssg/ssg.cxx`, this file includes platform-specific OpenGL context headers and has a `glIsValidContext()` function:

```c
#ifdef UL_MACINTOSH
#  include <agl.h>
#elif defined(UL_MAC_OSX)
#  include <OpenGL/CGLCurrent.h>
#elif defined(UL_WIN32)
   /* Nothing */
#else
#  include <GL/glx.h>
#endif
```

```c
static bool glIsValidContext ( void )
{
#if defined(CONSOLE)
  return true ;
#elif defined(UL_WIN32)
  return ( wglGetCurrentContext () != NULL ) ;
#elif defined(UL_MACINTOSH)
  return ( aglGetCurrentContext () != NULL ) ;
#elif defined(UL_MAC_OSX)
  return ( CGLGetCurrentContext () != NULL ) ;
#else
  return ( glXGetCurrentContext () != NULL ) ;
#endif
}
```

Without Emscripten support, the build fails with:

```
fntTXF.cxx:32:12: fatal error: 'GL/glx.h' file not found
   32 | #  include <GL/glx.h>
      |            ^~~~~~~~~~
```

Apply the same fix as `src/ssg/ssg.cxx` by adding Emscripten to the Windows branch:

```c
#ifdef UL_MACINTOSH
#  include <agl.h>
#elif defined(UL_MAC_OSX)
#  include <OpenGL/CGLCurrent.h>
#elif defined(UL_WIN32) || defined(UL_EMSCRIPTEN)
   /* Nothing */
#else
#  include <GL/glx.h>
#endif
```

Additionally, add an Emscripten case to `glIsValidContext()`:

```c
static bool glIsValidContext ( void )
{
#if defined(CONSOLE)
  return true ;
#elif defined(UL_WIN32)
  return ( wglGetCurrentContext () != NULL ) ;
#elif defined(UL_MACINTOSH)
  return ( aglGetCurrentContext () != NULL ) ;
#elif defined(UL_MAC_OSX)
  return ( CGLGetCurrentContext () != NULL ) ;
#elif defined(UL_EMSCRIPTEN)
  return true ;
#else
  return ( glXGetCurrentContext () != NULL ) ;
#endif
}
```

---

## `make install` Fix

By default, `make install` fails because `INSTALL` is set to `/c/Program Files/Git/usr/bin/install.exe -c`, and the space in "Program Files" breaks Makefile commands. To fix this issue, we can pass `INSTALL="$(pwd)/install-sh"` to configure, which uses the bundled autoconf install script instead.
